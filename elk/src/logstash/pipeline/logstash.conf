input {
  beats {
    port => 5044
    ssl_enabled => true
    ssl_certificate_authorities => ["/usr/share/logstash/certs/ca/ca.crt"]
    ssl_certificate => "/usr/share/logstash/certs/logstash/logstash.crt"
    ssl_key => "/usr/share/logstash/certs/logstash/logstash.key"
  }
}


filter {
  ## Parse brut Json
  json {
    source => "message"
    target => "app"
    tag_on_failure => ["_jsonparsefailure"]
  }

  ## Get app timestamp
  if [app][time] {
    date {
      match => ["[app][time]", "UNIX_MS"]
      target => "app_timestamp"
    }
  }

  ## Create first fields
  if ([app][service]) {
    mutate {
      add_field => {
        "service_name" => "%{[app][service]}"
      }
    }
  }

  if ([app][reqId]) {
    mutate {
      add_field => {
        "request_id" => "%{[app][reqId]}"
      }
    }
  } 

  if ([app][event]) {
    mutate {
      add_field => {
        "event_type" => "%{[app][event]}"
      }
    }
  }

  ## Convert level
  translate {
    source => "[app][level]"
    target => "log_level"
    dictionary => {
      "10" => "TRACE"
      "20" => "DEBUG"
      "30" => "INFO"
      "40" => "WARN"
      "50" => "ERROR"
      "60" => "FATAL"
    }
    fallback => "UNKNOWN"
  }

  ## Clean fields
  mutate {
    remove_field => [ "[app][time]", "[event][original]", "[app][event]", "[app][reqId]", "[app][service]"]
  }
}

output {
  elasticsearch {
    index => "transcendence"
    hosts => "${ELASTIC_HOSTS}"
    user => "${ELASTIC_USER}"
    password => "${ELASTIC_PASSWORD}"
    ssl_enabled => true
    ssl_certificate_authorities => "/usr/share/logstash/certs/ca/ca.crt" 
  }
  #stdout { codec => rubydebug }
}

